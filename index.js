const mineflayer = require('mineflayer');
const express = require('express');
const app = express();

// ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑŸÖÿ®ÿ≥ÿ∑
const CONFIG = {
  username: 'MendingHunter',
  host: 'og_players11-G2lV.aternos.me',
  port: 41642,
  version: '1.21.1',
  
  // ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ®ÿ≠ÿ´
  villagerRange: 10,        // ŸÜÿ∑ÿßŸÇ ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÇÿ±ŸàŸäŸäŸÜ
  resetDelay: 3000,         // ÿ™ÿ£ÿÆŸäÿ± ÿ®ÿπÿØ ŸÉÿ≥ÿ± ŸàŸàÿ∂ÿπ lectern
  checkDelay: 2000          // ÿ™ÿ£ÿÆŸäÿ± ŸÇÿ®ŸÑ ŸÅÿ≠ÿµ ÿßŸÑÿ™ÿØÿßŸàŸÑ
};

let bot = null;
let isSearching = false;
let mendingFound = false;
let attempts = 0;
let myLectern = null;
let targetVillager = null;

const status = {
  state: 'offline',
  attempts: 0,
  hasLectern: false,
  villagerPos: null,
  lecternPos: null,
  lastAction: 'none'
};

// Web interface
app.get('/', (req, res) => {
  res.json({
    status: status.state,
    searching: isSearching,
    found: mendingFound,
    attempts: status.attempts,
    hasLectern: status.hasLectern,
    villagerPos: status.villagerPos,
    lecternPos: status.lecternPos,
    lastAction: status.lastAction
  });
});

app.listen(3000, () => console.log('üåê Simple Mending Bot on port 3000'));

function createBot() {
  console.log('ü§ñ Creating Simple Mending Bot...');
  
  bot = mineflayer.createBot({
    host: CONFIG.host,
    port: CONFIG.port,
    username: CONFIG.username,
    version: CONFIG.version,
    auth: 'offline'
  });

  bot.on('login', () => {
    console.log('‚úÖ Bot connected!');
    status.state = 'online';
  });

  bot.on('spawn', () => {
    console.log('üéØ Bot ready!');
    status.state = 'ready';
    
    // ÿ±ÿ≥ÿßŸÑÿ© Ÿàÿßÿ≠ÿØÿ© ŸÅŸÇÿ∑ ÿπŸÜÿØ ÿßŸÑÿ®ÿØÿ°
    setTimeout(() => {
      bot.chat('üîç Mending Hunter ready. Say "hunt" to start.');
      checkInventory();
    }, 2000);
  });

  bot.on('chat', (username, message) => {
    if (username === bot.username) return;
    
    const msg = message.toLowerCase();
    
    if (msg.includes('hunt') || msg.includes('start') || msg.includes('go')) {
      if (!checkInventory()) {
        bot.chat('‚ùå Need 1 lectern!');
        return;
      }
      
      if (!mendingFound) {
        bot.chat('üîç Hunting...');
        startSimpleHunt();
      } else {
        bot.chat('‚úÖ Already found!');
      }
    }
    
    if (msg.includes('stop')) {
      stopHunt();
    }
    
    if (msg.includes('check') || msg.includes('inv')) {
      checkInventory();
    }
    
    if (msg.includes('status')) {
      if (mendingFound) {
        bot.chat('üéâ MENDING FOUND!');
      } else if (isSearching) {
        bot.chat(`üîç Attempt: ${attempts}`);
      } else {
        bot.chat('üí§ Ready');
      }
    }
  });

  bot.on('error', (err) => {
    console.log('‚ùå Error:', err.message);
  });
}

function checkInventory() {
  const lecternItem = bot.inventory.items().find(item => item.name === 'lectern');
  status.hasLectern = !!lecternItem;
  
  if (lecternItem) {
    console.log(`üìö Lecterns in inventory: ${lecternItem.count}`);
    return true;
  } else {
    bot.chat('‚ùå No lectern!');
    console.log('‚ùå No lectern found in inventory');
    return false;
  }
}

async function startSimpleHunt() {
  if (isSearching || mendingFound) return;
  
  if (!checkInventory()) {
    return;
  }
  
  isSearching = true;
  attempts = 0;
  status.state = 'hunting';
  
  console.log('üîç SIMPLE MENDING HUNT STARTED!');
  
  try {
    await simpleHuntLoop();
  } catch (error) {
    console.log('‚ùå Hunt error:', error.message);
    bot.chat(`‚ùå Error: ${error.message}`);
    stopHunt();
  }
}

async function simpleHuntLoop() {
  // Find a villager first
  const villager = await findVillager();
  if (!villager) {
    bot.chat('‚ùå No villagers!');
    stopHunt();
    return;
  }
  
  targetVillager = villager;
  status.villagerPos = posString(villager.position);
  console.log(`üë§ Found villager at ${status.villagerPos}`);
  
  // Move closer to villager first
  const distance = bot.entity.position.distanceTo(villager.position);
  if (distance > 5) {
    console.log('üö∂ Moving closer to villager...');
    try {
      const goal = new bot.pathfinder.goals.GoalNear(villager.position.x, villager.position.y, villager.position.z, 3);
      await bot.pathfinder.goto(goal);
      console.log('‚úÖ Moved closer to villager');
    } catch (e) {
      console.log('‚ùå Could not move to villager, trying from current position');
    }
  }
  
  // Place lectern near villager
  const lecternPlaced = await placeLecternNearVillager(villager);
  if (!lecternPlaced) {
    bot.chat('‚ùå Cannot place lectern!');
    console.log('‚ùå All lectern placement strategies failed!');
    
    // Last resort: look for existing lectern in area
    const existingLectern = bot.findBlock({
      matching: 'lectern',
      maxDistance: 20
    });
    
    if (existingLectern) {
      console.log('üîÑ Using existing lectern for hunt...');
      myLectern = existingLectern;
      status.lecternPos = posString(existingLectern.position);
    } else {
      stopHunt();
      return;
    }
  }
  
  // Start the hunt loop
  while (isSearching && !mendingFound) {
    attempts++;
    status.attempts = attempts;
    
    console.log(`\nüéØ ATTEMPT ${attempts}`);
    status.lastAction = `attempt_${attempts}`;
    
    // Wait for villager to get job
    await sleep(CONFIG.checkDelay);
    
    // Check if villager has mending
    const hasMending = await checkVillagerForMending(targetVillager);
    if (hasMending) {
      // FOUND MENDING!
      console.log('üéâüéâüéâ MENDING FOUND! üéâüéâüéâ');
      bot.chat('üéâ MENDING FOUND!');
      bot.chat(`üìç ${status.villagerPos} (${attempts} attempts)`);
      
      mendingFound = true;
      status.state = 'mending_found';
      stopHunt();
      return;
    }
    
    // No mending, reset villager
    console.log('‚ùå No mending, resetting villager...');
    const resetSuccess = await resetVillagerWithLectern();
    if (!resetSuccess) {
      bot.chat('‚ùå Reset failed!');
      break;
    }
    
    // Progress report every 50 attempts only
    if (attempts % 50 === 0) {
      bot.chat(`üîç ${attempts} attempts...`);
    }
    
    await sleep(1000); // Small delay between attempts
  }
}

async function findVillager() {
  const villagers = Object.values(bot.entities).filter(entity => {
    return entity.name === 'villager' && 
           entity.position && 
           bot.entity.position.distanceTo(entity.position) <= CONFIG.villagerRange;
  });
  
  console.log(`üë• Found ${villagers.length} villagers in range`);
  
  if (villagers.length === 0) return null;
  
  // Get closest villager
  return villagers.reduce((closest, villager) => {
    const distA = bot.entity.position.distanceTo(closest.position);
    const distB = bot.entity.position.distanceTo(villager.position);
    return distB < distA ? villager : closest;
  });
}

async function placeLecternNearVillager(villager) {
  try {
    console.log('üìö TRYING DIFFERENT METHOD...');
    status.lastAction = 'placing_lectern';
    
    const lecternItem = bot.inventory.items().find(item => item.name === 'lectern');
    if (!lecternItem) {
      console.log('‚ùå No lectern in inventory!');
      return false;
    }
    
    console.log(`üéØ Villager at: ${posString(villager.position)}`);
    
    // Move closer to villager first
    const distance = bot.entity.position.distanceTo(villager.position);
    if (distance > 3) {
      console.log('üö∂ Moving closer to villager...');
      try {
        await bot.pathfinder.goto(new bot.pathfinder.goals.GoalNear(villager.position.x, villager.position.y, villager.position.z, 2));
        console.log('‚úÖ Moved closer');
      } catch (e) {
        console.log('‚ùå Could not move closer');
      }
    }
    
    await bot.equip(lecternItem, 'hand');
    await sleep(1000);
    console.log('‚úÖ Lectern equipped');
    
    // Simple approach: Find any block to place on
    const villagerPos = villager.position;
    const attempts = [
      { x: 1, y: 0, z: 0 },
      { x: -1, y: 0, z: 0 },
      { x: 0, y: 0, z: 1 },
      { x: 0, y: 0, z: -1 },
      { x: 2, y: 0, z: 0 },
      { x: -2, y: 0, z: 0 },
      { x: 0, y: 0, z: 2 },
      { x: 0, y: 0, z: -2 }
    ];
    
    for (const attempt of attempts) {
      const targetX = Math.floor(villagerPos.x + attempt.x);
      const targetY = Math.floor(villagerPos.y + attempt.y);
      const targetZ = Math.floor(villagerPos.z + attempt.z);
      
      console.log(`üîç Checking position: ${targetX}, ${targetY}, ${targetZ}`);
      
      // Check the block below target position
      const blockBelow = bot.blockAt(new bot.vec3.Vec3(targetX, targetY - 1, targetZ));
      const blockAt = bot.blockAt(new bot.vec3.Vec3(targetX, targetY, targetZ));
      
      console.log(`  - Block below: ${blockBelow ? blockBelow.name : 'null'}`);
      console.log(`  - Block at: ${blockAt ? blockAt.name : 'null'}`);
      
      if (blockBelow && 
          blockBelow.name !== 'air' && 
          blockAt && 
          blockAt.name === 'air') {
        
        console.log(`‚úÖ GOOD SPOT! Trying to place lectern...`);
        
        try {
          // Method 1: Basic placement
          await bot.placeBlock(blockBelow, new bot.vec3.Vec3(targetX, targetY, targetZ));
          await sleep(2000);
          
          // Check if it worked
          const placedBlock = bot.blockAt(new bot.vec3.Vec3(targetX, targetY, targetZ));
          console.log(`  - After placement: ${placedBlock ? placedBlock.name : 'null'}`);
          
          if (placedBlock && placedBlock.name === 'lectern') {
            myLectern = placedBlock;
            status.lecternPos = `${targetX}, ${targetY}, ${targetZ}`;
            console.log(`üéâ LECTERN PLACED! At: ${status.lecternPos}`);
            return true;
          } else {
            console.log(`‚ùå Placement failed - got: ${placedBlock ? placedBlock.name : 'nothing'}`);
          }
          
        } catch (error1) {
          console.log(`‚ùå Method 1 failed: ${error1.message}`);
          
          // Method 2: Try different approach
          try {
            console.log('üîÑ Trying method 2...');
            
            const referenceBlock = blockBelow;
            const faceVector = new bot.vec3.Vec3(0, 1, 0);
            
            await bot.placeBlock(referenceBlock, faceVector);
            await sleep(2000);
            
            const placedBlock2 = bot.blockAt(new bot.vec3.Vec3(targetX, targetY, targetZ));
            if (placedBlock2 && placedBlock2.name === 'lectern') {
              myLectern = placedBlock2;
              status.lecternPos = `${targetX}, ${targetY}, ${targetZ}`;
              console.log(`üéâ LECTERN PLACED WITH METHOD 2! At: ${status.lecternPos}`);
              return true;
            }
            
          } catch (error2) {
            console.log(`‚ùå Method 2 also failed: ${error2.message}`);
            continue;
          }
        }
      } else {
        console.log(`‚ùå Bad position - no solid ground or space occupied`);
      }
    }
    
    console.log('‚ùå ALL PLACEMENT ATTEMPTS FAILED!');
    
    // Last resort: just find ANY lectern nearby and use it
    console.log('üîç Looking for existing lectern to use...');
    const existingLectern = bot.findBlock({
      matching: 'lectern',
      maxDistance: 15
    });
    
    if (existingLectern) {
      console.log(`‚úÖ Found existing lectern at ${posString(existingLectern.position)}`);
      myLectern = existingLectern;
      status.lecternPos = posString(existingLectern.position);
      return true;
    }
    
    return false;
    
  } catch (error) {
    console.log('‚ùå MAJOR ERROR:', error.message);
    console.log('‚ùå ERROR STACK:', error.stack);
    return false;
  }
}

// Remove the complex functions and keep it SUPER SIMPLE
async function tryPlaceLectern(position) {
  // This function is now unused - we use the simple method above
  return false;
}

async function forcePlaceLectern(position) {
  // This function is now unused - we use the simple method above  
  return false;
}

async function checkVillagerForMending(villager) {
  try {
    console.log('üîç Checking villager for mending...');
    status.lastAction = 'checking_trades';
    
    // Move closer to villager
    const distance = bot.entity.position.distanceTo(villager.position);
    if (distance > 4) {
      const goal = new bot.pathfinder.goals.GoalNear(villager.position.x, villager.position.y, villager.position.z, 2);
      await bot.pathfinder.goto(goal);
    }
    
    // Open trade window
    const window = await bot.openVillager(villager);
    if (!window || !window.trades) {
      console.log('‚ùå No trades available');
      if (window) bot.closeWindow(window);
      return false;
    }
    
    console.log(`üí∞ Checking ${window.trades.length} trades...`);
    
    // Check each trade for mending book
    for (let i = 0; i < window.trades.length; i++) {
      const trade = window.trades[i];
      if (!trade.outputItem) continue;
      
      if (trade.outputItem.name === 'enchanted_book') {
        console.log(`üìñ Found enchanted book in trade ${i + 1}`);
        
        const isMending = checkForMending(trade.outputItem);
        if (isMending) {
          bot.closeWindow(window);
          return true; // MENDING FOUND!
        }
      }
    }
    
    console.log('‚ùå No mending in this villager');
    bot.closeWindow(window);
    return false;
    
  } catch (error) {
    console.log('‚ùå Check trades error:', error.message);
    return false;
  }
}

async function resetVillagerWithLectern() {
  try {
    console.log('üîÑ SIMPLE reset - breaking and placing lectern...');
    status.lastAction = 'resetting_villager';
    
    if (!myLectern) {
      console.log('üîç No lectern reference, searching...');
      myLectern = bot.findBlock({
        matching: 'lectern',
        maxDistance: 10
      });
      
      if (!myLectern) {
        console.log('‚ùå No lectern found anywhere!');
        return false;
      }
    }
    
    const lecternPos = myLectern.position;
    console.log(`üî® Breaking lectern at: ${posString(lecternPos)}`);
    
    // Break the lectern
    try {
      await bot.dig(myLectern);
      console.log('‚úÖ Lectern broken!');
    } catch (breakError) {
      console.log('‚ùå Failed to break lectern:', breakError.message);
      return false;
    }
    
    // Wait for villager to lose job
    await sleep(CONFIG.resetDelay);
    
    // Place it back SIMPLY
    console.log('üìö Placing lectern back...');
    const lecternItem = bot.inventory.items().find(item => item.name === 'lectern');
    
    if (!lecternItem) {
      console.log('‚ùå No lectern to place back!');
      return false;
    }
    
    await bot.equip(lecternItem, 'hand');
    await sleep(500);
    
    // Get the ground block below where lectern was
    const groundBlock = bot.blockAt(lecternPos.offset(0, -1, 0));
    
    if (groundBlock && groundBlock.name !== 'air') {
      console.log(`üìö Placing lectern back on: ${groundBlock.name}`);
      
      try {
        const vec3 = bot.vec3;
        await bot.placeBlock(groundBlock, vec3(0, 1, 0));
        
        await sleep(1000);
        
        // Check if lectern was placed back
        const newLectern = bot.blockAt(lecternPos);
        if (newLectern && newLectern.name === 'lectern') {
          myLectern = newLectern;
          console.log('‚úÖ Lectern placed back successfully!');
          return true;
        } else {
          console.log('‚ùå Failed to place lectern back');
          return false;
        }
        
      } catch (placeError) {
        console.log('‚ùå Error placing lectern back:', placeError.message);
        return false;
      }
    } else {
      console.log('‚ùå No ground to place lectern back on!');
      return false;
    }
    
  } catch (error) {
    console.log('‚ùå Reset error:', error.message);
    return false;
  }
}

function checkForMending(item) {
  if (!item || !item.nbt) return false;
  
  try {
    const nbt = item.nbt;
    
    if (nbt.value && nbt.value.StoredEnchantments) {
      const enchantments = nbt.value.StoredEnchantments.value.value;
      
      for (const ench of enchantments) {
        const enchId = ench.id ? ench.id.value : '';
        if (enchId.includes('mending')) {
          console.log('üéâ MENDING ENCHANTMENT FOUND!');
          return true;
        }
      }
    }
    
    return false;
  } catch (error) {
    console.log('‚ùå NBT check error:', error.message);
    return false;
  }
}

function stopHunt() {
  console.log('‚èπÔ∏è Stopping hunt');
  isSearching = false;
  status.state = mendingFound ? 'mending_found' : 'ready';
  status.lastAction = 'hunt_stopped';
}

function posString(pos) {
  return `${Math.floor(pos.x)}, ${Math.floor(pos.y)}, ${Math.floor(pos.z)}`;
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Anti-idle
setInterval(() => {
  if (bot && bot.entity && !isSearching) {
    const yaw = bot.entity.yaw + (Math.random() - 0.5) * 0.1;
    bot.look(yaw, bot.entity.pitch);
  }
}, 30000);

// Startup
console.log('üöÄ SIMPLE MENDING BOT STARTING...');
console.log('üìö Uses only 1 lectern - breaks and replaces it');
console.log('üéØ No emeralds needed - just checks trades');
console.log('‚ö° Super simple and efficient!');

createBot();
